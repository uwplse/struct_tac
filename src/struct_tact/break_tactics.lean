import .traversals

open tactic

/- We match on names which are generated by the internal match-wrapper machinery. -/
meta def is_match_wrapper (n : name): bool :=
match n.components.ilast with
| name.mk_string s _ := s.to_list.take 7 = "_match_".to_list
| _ := bool.ff
end

/- Select the scrutinee from a list of arguments to the match expression, current heuristic is simple and non-robust. -/
meta def find_scrutinee : list expr → tactic expr :=
fun xs, return (xs.ilast)

meta def rw_one (hyp_name : option name) (eq_n : name) : tactic unit :=
match hyp_name with
| none := do eq ← get_local eq_n, rewrite_target eq
| some hn :=
 do eq ← get_local eq_n,
    H ← get_local hn,
    rewrite_hyp eq H,
    return ()
end

/- Removes reflexive equalities (i.e a = a). -/
meta def clear_refl_eqs : tactic unit :=
  do ls ← local_context,
     for_m ls (λ l,
       do ty ← infer_type l,
       -- is there a better way to write this?
       (do (a, b) ← match_eq ty,
           if a = b
           then clear l
           else return ()) <|> return ()),
     return ()

meta def intros_and_subst (hyp_name : option name) : tactic unit :=
do tgt ← target,
   if tgt.is_pi
   then do n ← get_unused_name `a,
           H ← intro n,
           -- trace H,
           ty ← infer_type H,
           try (rw_one hyp_name n),
           intros_and_subst
    else return ()

meta def split_app (e : expr) : tactic (expr × list expr) :=
match e with
| (expr.app _ _) :=
  let head := expr.get_app_fn e,
      args := expr.get_app_args e
  in return (head, args)
| _ := tactic.fail "expected an application found ..."
end

meta def find_match (head : expr) (args : list expr) : tactic (name × expr) :=
if is_match_wrapper head.const_name
then do scrut ← find_scrutinee args,
        return $ (head.const_name, scrut)
else tactic.fail "head is not match" -- todo improve me

meta def destruct_subst_dsimp (hyp_name : option name) (match_name : name) (scrut : expr) :=
seq (destruct scrut) $
   seq (intros_and_subst hyp_name)
        (all_goals $ match hyp_name with
            | none := dsimp_target none [match_name, `id_rhs]
            | some n :=
              do H ← get_local n,
                 dsimp_hyp H none [match_name, `id_rhs],
                return ()
            end)

meta def break_match_or_fail (hyp_name : option name) : expr → tactic unit
| (expr.app f g) :=
  subterms (expr.app f g) (fun head args,
    do -- trace head,
       (match_name, scrut) ← find_match head args,
       destruct_subst_dsimp hyp_name match_name scrut,
       return ())
| _ := tactic.fail "break_match: does not support this term"

meta def break_match_hyp : tactic unit :=
-- The English name for `;`.
seq
-- First try to find a hypothesis where break_match succeds
(until_first_hyp (λ loc,
  do ty ← infer_type loc,
     break_match_or_fail loc.local_pp_name ty))
-- If one succeds, clean up the context for all goals, by first clearing redundant equalities
-- then try to prune goals using contradiction.
(do clear_refl_eqs, try contradiction)

meta def break_match_goal : tactic unit :=
do tgt ← target,
   match tgt with
   | (expr.app f g) := break_match_or_fail none (expr.app f g)
   | _ := return ()
   end

meta def break_if_or_fail (loc : option name) : expr → tactic unit
| (expr.app f g) :=
  subterms (expr.app f g) (fun head args,
     match head with
      -- add support for dite
      | (expr.const `ite _) :=
        match args with
        | (pred :: _ ) :=
          do n ← get_unused_name `p,
             -- tactic.trace pred,
             by_cases pred n,
             all_goals `[simp * at *] -- replace this
        -- | (expr.const `dite _) :=
        --   do n ← get_unused_name `p,
        --      tactic.trace pred,
        --      by_cases pred n,
        --      all_goals `[simp * at *] -- replace this
        -- | (expr.const `dite _) :=
        | [] := tactic.fail "should be unreachable"
        end
      | _ := tactic.fail "no if"
      end)
| _ := tactic.fail "break_if: does not support this term"

meta def is_recursor : name → tactic bool
| (name.mk_string s n) :=
  if s = "rec"
  then return true
  else return false
| _ := return false

#eval (is_recursor `prod.rec)

meta def break_irrefutable_or_fail (hyp_name : option name) (h : expr) : tactic unit :=
  subterms h (fun h args,
    do is_rec ← (fun b, h.is_constant && b) <$> is_recursor h.const_name,
       if is_rec
       then destruct_subst_dsimp hyp_name h.const_name args.ilast
       else tactic.fail "")

meta def break_irrefutable_hyp : tactic unit :=
until_first_hyp (λ loc,
  do ty ← infer_type loc,
     break_irrefutable_or_fail loc.local_pp_name ty)

meta def break_if_hyp : tactic unit :=
(until_first_hyp (λ loc,
  do ty ← infer_type loc,
     break_if_or_fail loc.local_pp_name ty))

meta def break_if_target : tactic unit :=
do tgt ← target,
   match tgt with
   | (expr.app f g) := break_if_or_fail none (expr.app f g)
   | _ := return ()
   end

meta def break_match :=
break_match_hyp <|> break_match_goal

meta def break_if :=
break_if_hyp <|> break_if_target

meta def case_split :=
break_if <|> break_match

open interactive.types

meta def match_head (rhs lhs : expr) : tactic unit :=
 let head_rhs := rhs.get_app_fn,
     head_lhs := lhs.get_app_fn
 in if head_rhs = head_lhs
 then return ()
 else tactic.fail "match_head, no match"

-- Not sure about this name anymore
meta def find_inversion : tactic unit :=
until_first_hyp $ λ h,
do ty ← infer_type h,
   (rhs, lhs) ← match_eq ty,
   match_head rhs lhs,
   cases h
